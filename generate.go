package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"
	"golang.org/x/tools/imports"
)

var templ = `// Code generated by github.com/Bin-Huang/make-constructor; DO NOT EDIT.

package {{.PkgName}}

{{ range .Constructors }}
// {{.Name}} Create a new {{.Struct}}
func {{.Name}}({{.Params}}) *{{.Struct}} {
    return &{{.Struct}} {
        {{.Fields}}
    }
}
{{ end }}
`

func generateCode(pkgName string, importResuts []ResultImport, results []Result) (string, error) {
	// remove duplicate imports
	importResuts = UniqueImports(importResuts)

	// generate code with template
	t, err := template.New("").Parse(templ)
	if err != nil {
		return "", err
	}
	data := o{
		"PkgName":     pkgName,
		"Imports":     importResuts,
		"Constructor": []o{},
	}
	constructors := []o{}
	for _, result := range results {
		params := []string{}
		fields := []string{}
		for _, field := range result.Fields {
			params = append(params, fmt.Sprintf("%v %v", toLowerCamel(field.Name), field.Type))
			fields = append(fields, fmt.Sprintf("%v: %v,", field.Name, toLowerCamel(field.Name)))
		}
		constructors = append(constructors, o{
			"Name":   "New" + strcase.ToCamel(result.StructName),
			"Struct": result.StructName,
			"Params": strings.Join(params, ", "),
			"Fields": strings.Join(fields, "\n"),
		})
	}
	data["Constructors"] = constructors
	var buffer bytes.Buffer
	err = t.Execute(&buffer, data)
	if err != nil {
		return "", err
	}

	// format code
	buf, err := FormatSource(buffer.Bytes())
	if err != nil {
		return "", err
	}
	return string(buf), nil
}

// FormatSource ...
func FormatSource(source []byte) ([]byte, error) {
	return imports.Process("", source, &imports.Options{
		AllErrors:  true,
		Comments:   true,
		TabIndent:  true,
		TabWidth:   8,
		Fragment:  true,
	})
}

// UniqueImports remove duplicate imports, return unqiue imports
func UniqueImports(imports []ResultImport) []ResultImport {
	hash := map[string]ResultImport{}
	for _, importInfo := range imports {
		key := fmt.Sprintf("%v|%v", importInfo.Name, importInfo.Path)
		hash[key] = importInfo
	}
	ret := []ResultImport{}
	for _, importInfo := range hash {
		ret = append(ret, importInfo)
	}
	return ret
}

type o map[string]interface{}
